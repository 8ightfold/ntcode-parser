//===- ParserTail.cpp -----------------------------------------------===//
//
// Copyright (C) 2024 Eightfold
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
//     limitations under the License.
//
//===----------------------------------------------------------------===//

#include "Emitter.hpp"
#include "llvm/ADT/SmallString.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/WithColor.h"

using namespace llvm;

static bool MakePathWithExtension(SmallVectorImpl<char>& Out, StringRef Ext);
static bool PrintErrorCode(const std::error_code& EC, StringRef Msg = "");

static constexpr char EmitHeader[] =
R"~(/* Autogenerated, DO NOT MODIFY! */

#include <Sys/OpaqueError.hpp>

#define $NewPErr(val, msg) \
 $NewOpqErr(ErrorGroup::OSError, val, msg, \
  OpqErrorExtra {.severity = ErrorSeverity::CURR_SEVERITY})

using namespace hc;
using namespace hc::sys;

namespace {

)~";

static constexpr char EmitFooter[] =
R"~(
} // namespace `anonymous`

OpaqueError SysErr::GetOpaqueError(OpqErrorID ID) {
  const OpqErrorID base = (ID & 0x0FFFFFFF);
  switch (ID & 0xF0000000) {
   case 0x00000000:
    return _SuccessGroup::Get(base);
   case 0x40000000:
    return _InfoGroup::Get(base);
   case 0x80000000:
    return _WarningGroup::Get(base);
   case 0xC0000000:
    return _ErrorGroup::Get(base);
   default:
    return nullptr;
  }
}
)~"; 

bool NtCodeParser::writeToFile(StringRef Filename, bool Debug) {
  using namespace llvm::sys;
  if (Debug)
    return emitGroupData(outs());

  SmallString<128> OutputCpp = Filename;
  if (MakePathWithExtension(OutputCpp, "cpp"))
    return false;
  
  std::error_code EC;
  raw_fd_ostream OS {OutputCpp, EC};
  if (PrintErrorCode(EC, "Error opening file"))
    return false;
  return emitGroupData(OS);
}

bool NtCodeParser::emitGroupData(raw_ostream& OS) {
  using enum StatusGroup;
  GroupEmitter Emitter(OS);

  OS << EmitHeader << '\n';
  Emitter.emit(SUCCESS, successes);
  Emitter.emit(INFO,    infos);
  Emitter.emit(WARNING, warnings);
  Emitter.emit(ERROR,   errors);
  OS << EmitFooter << '\n';

  if (!Emitter.emitSuccessful()) {
    ArrayRef<StringRef> Failures = Emitter.getFailures();
    WithColor::error();
    errs() << "Emmission failed on group[s]: {" << Failures[0];
    for (StringRef Failure : Failures.drop_front())
      errs() << ", " << Failure;
    errs() << "}\n";
    return false;
  }
  
  return true;
}

//=== Statics ===//

bool MakePathWithExtension(
 SmallVectorImpl<char>& Out, StringRef Ext) {
  using namespace llvm::sys;
  if (path::is_relative(Out)) {
    if (auto EC = fs::make_absolute(Out))
      return PrintErrorCode(EC, "Error creating path");
  }
  path::replace_extension(Out, Ext);
  return false;
}

bool PrintErrorCode(const std::error_code& EC, StringRef Msg) {
  if (!EC)
    return false;
  WithColor::error();
  if (!Msg.empty())
    errs() << Msg << ": ";
  errs() << EC.message() << '\n';
  return true;
}